<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Karen Crashout â€” Minion Voices + Bubbles + Powerups</title>
<style>
  :root { --bg:#efe9dc; --panel:#0d1328; --ink:#e6eeff; --muted:#9fb0d8; --btn:#1a2143; --btnH:#232d58; --good:#22c55e; --bad:#ef4444; --cy:#69e7c3; }
  html,body{height:100%;margin:0;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  body{display:grid;grid-template-columns:360px 1fr;background:var(--bg)}
  #ui{background:var(--panel);color:var(--ink);padding:14px;overflow:auto;box-shadow:inset -1px 0 0 rgba(255,255,255,.06)}
  h1{margin:0 0 8px;font-size:20px}
  small{color:var(--muted)}
  .row{margin:10px 0}
  .btn{display:inline-block;background:var(--btn);color:#eaf2ff;padding:8px 12px;border-radius:10px;cursor:pointer;user-select:none;margin:4px 6px 0 0}
  .btn:hover{background:var(--btnH)}
  .chip{display:inline-block;padding:5px 9px;border-radius:999px;background:#1c244a;margin:2px 6px 0 0}
  .sel{outline:2px solid var(--cy)}
  .slider{width:100%}
  .kv{font-family:ui-monospace,Consolas,Menlo,monospace}
  canvas{width:100%;height:100%;display:block;background:#f7f3ea}
  .title{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(7,9,16,.72);z-index:7}
  .card{background:#0b1022;color:#cfe0ff;width:min(920px,92vw);padding:22px;border-radius:16px;box-shadow:0 12px 50px rgba(0,0,0,.45)}
  .pill{background:#182045;border-radius:999px;padding:6px 10px;margin-right:6px;display:inline-block}
</style>
</head>
<body>

<div id="ui">
  <h1>Karen Crashout</h1>
  <small>Minion & boss voices+bubbles â€¢ Free move â€¢ Powerups â€¢ Props â€¢ 3Ã— bosses</small>

  <div class="row">
    <span class="btn" id="btnPlay">Play</span>
    <span class="btn" id="btnPause">Pause</span>
    <span class="btn" id="btnResetBoss">Reset Boss Picks</span>
  </div>

  <div class="row">
    <strong>Level</strong><br>
    <span class="btn lvl" data-lvl="coffee">Coffee Shop</span>
    <span class="btn lvl" data-lvl="grocery">Grocery</span>
    <span class="btn lvl" data-lvl="parking">Parking Lot</span>
    <span class="btn lvl" data-lvl="neighborhood">Neighborhood</span>
    <span class="btn lvl" data-lvl="office">Office (blonde boss)</span>
  </div>

  <div class="row">
    <strong>Player Skin (default)</strong><br>
    <span class="chip skin sel" data-skin="M1walk.png">M1</span>
    <span class="chip skin" data-skin="M2walk.png">M2</span>
    <span class="chip skin" data-skin="M3walk.png">M3</span>
    <div style="color:#9fb0d8;margin-top:6px;font-size:12px">
      Grocery forces M1. Office randomly uses M2 or M3 each run.
    </div>
  </div>

  <div class="row">
    <strong>Difficulty</strong><br>
    <label>Spawn Rate (higher = more)</label>
    <input id="spawnRate" class="slider" type="range" min="0.5" max="2.0" step="0.05" value="0.5">
    <label>Enemy HP Multiplier</label>
    <input id="hpMult" class="slider" type="range" min="0.6" max="2.0" step="0.05" value="1.0">
    <label>Player Damage Taken Multiplier</label>
    <input id="dmgMult" class="slider" type="range" min="0.5" max="2.0" step="0.05" value="1.0">
  </div>

  <div class="row">
    <strong>Audio</strong><br>
    <span class="chip" id="toggleVoices">Voices: <span id="vState">On</span></span>
    <span class="chip" id="toggleSfx">SFX: <span id="sState">On</span></span>
  </div>

  <div class="row">
    <strong>Info</strong><br>
    <div>Level: <span id="lblLevel" class="kv">coffee</span></div>
    <div>Boss: <span id="lblBoss" class="kv">â€”</span></div>
    <div>Boss Scale: <span id="lblScale" class="kv">â€”</span></div>
    <div>Score: <span id="lblScore" class="kv">0</span></div>
    <div>Best (<span id="bestLevel" class="kv">coffee</span>): <span id="lblBest" class="kv">0</span></div>
    <div>Lives: <span id="lblLives" class="kv">3</span></div>
    <div>Powerups: <span id="lblPwr" class="kv">â€”</span></div>
  </div>

  <div class="row"><small>Move: WASD/Arrows â€¢ Throw: Space â€¢ Pause: Esc</small></div>
</div>

<canvas id="game" width="1280" height="720"></canvas>

<div id="title" class="title" style="display:flex">
  <div class="card">
    <div id="titleHeading" style="font-size:28px;font-weight:800;margin-bottom:6px">Karen Crashout â€” Press Play</div>
    <div style="color:#9fb1df;margin-bottom:10px">Minions and bosses talk (bubbles + TTS). Only hits hurt. Bosses are huge.</div>
    <div class="pill">WASD move</div><div class="pill">Space throw</div><div class="pill">Esc pause</div>
    <div style="margin-top:14px">
      <span class="btn" id="titlePlay">Play</span>
      <span class="btn lvl" data-lvl="coffee">Coffee</span>
      <span class="btn lvl" data-lvl="grocery">Grocery</span>
      <span class="btn lvl" data-lvl="office">Office</span>
    </div>
  </div>
</div>

<script>
/* ============================ CONFIG =================================== */
const PLAYER_SKINS = ["M1walk.png","M2walk.png","M3walk.png"];
const POOLS = {
  coffee:       ["K1walk.png","K3walk.png","K4walk.png"],
  grocery:      ["K1walk.png","K2walk.png","K4walk.png"],
  parking:      ["K1walk.png","K4walk.png"],
  neighborhood: ["K1walk.png","K2walk.png","K3walk.png","K4walk.png"],
  office:       ["K2walk.png","K3walk.png"] // blonde-only
};

const PLAYER_EMOJI = {
  coffee:       {ch:"â˜•", stamina:12, speed:560, damage:16},
  grocery:      {ch:"ðŸ›’", stamina:22, speed:480, damage:26},
  parking:      {ch:"ðŸš§", stamina:18, speed:520, damage:20},
  neighborhood: {ch:"ðŸ“°", stamina:10, speed:560, damage:12},
  office:       {ch:"ðŸ“Ž", stamina:14, speed:540, damage:16}
};
const MINION_EMOJI = ["ðŸ’„","ðŸ¬","ðŸ¥¤"];
const OFFICE_BOSS_EMOJI = [
  {ch:"ðŸ´", speed:520, damage:18},
  {ch:"ðŸ”¥", speed:460, damage:22},
  {ch:"ðŸš§", speed:380, damage:16}
];

/* ====== Lines ======= */
const LINES = {
  coffee: [
    "I want to talk to your manager!",
    "I need thirty specialty drinks in five minutes!",
    "I ordered nonfat foam-free oat whip â€” do it again!",
    "This coupon never expires â€” it says so!"
  ],
  grocery: [
    "Price match every item, now!",
    "I saw it cheaper online â€” honor it!",
    "Bag it again, properly this time!",
    "I need twelve returns without a receipt."
  ],
  parking: [
    "That spot is mine â€” I was thinking about it!",
    "You can't ticket me â€” I'm special!",
    "Why is this cone in my way?!",
    "Do you know who I am?!"
  ],
  neighborhood: [
    "Your lawn is two inches too high!",
    "Quiet hours begin at 3PM â€” learn it!",
    "I'm calling the HOA right now!",
    "Who approved that mailbox color?"
  ],
  office: [
    "You aren't important enough to matter!",
    "You're stealing from this company â€” I can prove it!",
    "Someone sounds entitled!",
    "No more lunch cards! Why are we paying bonuses?",
    "My lifestyle can't afford what we are paying you!"
  ],
  bossLow: [
    "This isn't over!",
    "Security! SE-CUR-I-TY!",
    "Where is your manager?!",
    "You will hear from corporate!"
  ],
  onDefeat: [
    "I'm leaving a one-star review!",
    "Unacceptable!",
    "Refund! Refund! Refund!"
  ]
};

/* ============================ UI refs ================================== */
const $ = s => document.querySelector(s);
const ui = {
  level: $("#lblLevel"), boss: $("#lblBoss"), scale: $("#lblScale"),
  score: $("#lblScore"), best: $("#lblBest"), bestLevel: $("#bestLevel"),
  spawn: $("#spawnRate"), hp: $("#hpMult"), dmg: $("#dmgMult"),
  vState: $("#vState"), sState: $("#sState"), lives: $("#lblLives"), pwr: $("#lblPwr")
};
const titleOverlay = $("#title");
const titleHeading = $("#titleHeading");

/* ============================ Input ==================================== */
const keys = Object.create(null);
addEventListener("keydown", e=>{ keys[e.code]=true; if(e.code==="Escape") paused=!paused; });
addEventListener("keyup",   e=>{ keys[e.code]=false; });

/* ============================ Audio (voices + sfx) ===================== */
let voicesOn = true, sfxOn = true, ac;
let femaleVoices = [];

// voice discovery
function refreshVoices(){
  femaleVoices = [];
  try {
    const list = speechSynthesis.getVoices() || [];
    femaleVoices = list.filter(v => /female|woman|samantha|victoria|zira|karen|espeakf/i.test((v.name||"")+(v.lang||"")));
  } catch(e){}
}
if ("speechSynthesis" in window) {
  speechSynthesis.onvoiceschanged = refreshVoices;
  refreshVoices();
}

// unlock audio on first intent (Play/Level click)
function initAudio(){
  try {
    ac = ac || new (window.AudioContext||window.webkitAudioContext)();
    if (ac.state === "suspended") ac.resume();
  } catch(e){}
}

// Robust TTS manager (single channel, boss-priority, hard cancel)
const TTS = {
  busy:false, bossUntil:0, utter:null,
  speak(line, channel="enemy"){
    if (!voicesOn || !("speechSynthesis" in window)) return;
    const now = performance.now();

    if (channel === "boss") {
      try { speechSynthesis.cancel(); } catch(e){}
      this.busy = false;
      this.bossUntil = now + 800;
    } else {
      if (this.busy || now < this.bossUntil) return; // skip audio; bubble still shows
    }

    const u = new SpeechSynthesisUtterance(line);
    const v = femaleVoices[0]; if (v) u.voice = v;
    u.pitch=1.6; u.rate=1.25; u.volume=0.9;
    u.onstart = ()=>{ this.busy=true; };
    const cleanup = ()=>{ this.busy=false; this.utter=null; };
    u.onend = cleanup; u.onerror = cleanup;

    this.utter = u;
    try { speechSynthesis.speak(u); } catch(e){ cleanup(); }
  },
  stop(){ try{ if("speechSynthesis" in window) speechSynthesis.cancel(); }catch(e){} this.busy=false; this.utter=null; this.bossUntil=0; }
};

// simple beeps
function sfx(freq=880, dur=0.07, gain=0.08, type="square"){
  if (!sfxOn) return;
  initAudio();
  const o=ac.createOscillator(), g=ac.createGain();
  o.type=type; o.frequency.value=freq; g.gain.value=gain;
  g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+dur);
  o.connect(g).connect(ac.destination); o.start(); o.stop(ac.currentTime+dur);
}
const sfxThrow = ()=>sfx(1200,0.07,0.08,"square");
const sfxHit   = ()=>sfx(220,0.09,0.10,"sawtooth");
const sfxPup   = ()=>sfx(980,0.12,0.12,"triangle");

// kill stuck speech when tab loses focus
document.addEventListener('visibilitychange', ()=>{ if (document.hidden) TTS.stop(); });

/* ============================ Sprite Anim ============================== */
function loadImage2(url){ return new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=url; }); }
const ROW_MAP = { up:0, left:1, down:2, right:3 };

async function SpriteGrid(url){
  const img = await loadImage2(url);
  const rows=4, fh=Math.floor(img.height/rows), fw=fh, cols=Math.floor(img.width/fw);
  return {
    img, fw, fh, cols,
    rect(dir,frame){ const r=(ROW_MAP[dir]??0), c=frame%cols; return {sx:c*fw, sy:r*fh, sw:fw, sh:fh}; },
    draw(ctx,x,y,dir,frame,scale=1){ const {sx,sy,sw,sh}=this.rect(dir,frame); const dw=sw*scale, dh=sh*scale;
      ctx.drawImage(this.img,sx,sy,sw,sh, Math.round(x-dw/2), Math.round(y-dh), Math.round(dw), Math.round(dh)); }
  };
}
class Animator{
  constructor(grid,fps=10){ this.g=grid; this.fps=fps; this.acc=0; this.frame=0; this.dir="left"; this.state="idle"; this.speed=0; this.freeze=0; }
  update(dt){
    if(this.freeze>0){ this.freeze-=dt; return; }
    const mul = this.state==="dash" ? 2.0 : this.state==="walk" ? (0.55 + Math.min(1.6, this.speed/160)) : 0.6;
    const fps=this.fps*mul; this.acc+=dt*fps; while(this.acc>=1){ this.frame=(this.frame+1)%this.g.cols; this.acc-=1; }
  }
  draw(ctx,x,y,scale=1){ const idle=(this.g.cols>=8?4:0); const f=this.state==="idle"?idle:this.frame; this.g.draw(ctx,x,y,this.dir,f,scale); }
}

/* ============================ Helpers & Boxes ========================== */
const lerp=(a,b,t)=>a+(b-a)*Math.max(0,Math.min(1,t));
function clampRect(x,y,box){ return { x: Math.max(box.l, Math.min(box.r, x)), y: Math.max(box.t, Math.min(box.b, y)) }; }
function len2(vx,vy){ return Math.hypot(vx,vy)||1; }
function nrm(vx,vy){ const L = len2(vx,vy); return [vx/L, vy/L]; }
function playerBox(){ return { l:60, r:Math.floor(canvas.width*0.48), t:110, b:canvas.height-40 }; }
function bossBox(){ return { l:Math.floor(canvas.width*0.55), r:canvas.width-60, t:110, b:canvas.height-40 }; }

/* ============================ Game State =============================== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let level = localStorage.getItem("lastLevel") || "coffee";
let skin  = localStorage.getItem("playerSkin") || "M1walk.png";
let paused = false;

let player=null, boss=null;
let enemies=[], playerShots=[], enemyShots=[], props=[], powerups=[];
let kills=0, needBoss=true, spawnTimer=0, powerTimer=0, score=0;
let crowdChatterTimer = 3.5; // periodic minion chatter

/* ============================ Utility ================================= */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rand =(a,b)=>a+Math.random()*(b-a);
const pick = arr => arr[(Math.random()*arr.length)|0];
function drawEmoji(ch,x,y,size){
  ctx.save();
  ctx.font = `bold ${size}px "Segoe UI Emoji","Apple Color Emoji","Noto Color Emoji",sans-serif`;
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.shadowColor="rgba(0,0,0,.25)"; ctx.shadowBlur=4;
  ctx.fillText(ch,x,y);
  ctx.restore();
}
function hitCircle(ax,ay,ar,bx,by,br){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy <= (ar+br)*(ar+br); }

/* ============================ Speech bubbles =========================== */
let delta = 0;
function say(entity, line, secs=2.5){
  if (!entity) return;
  entity.speech = { text: line, t: secs };
  // throttle per entity
  const now = performance.now();
  const next = (entity._nextVoiceAt||0);
  const isBoss = (typeof boss !== "undefined" && entity === boss);
  const channel = isBoss ? "boss" : "enemy";
  if (now >= next) {
    TTS.speak(line, channel);
    entity._nextVoiceAt = now + (isBoss ? 1200 : 1600);
  }
}
function drawBubble(x,y,text){
  if(!text) return;
  const pad=6, r=8, maxW=240;
  ctx.save();
  ctx.font="12px system-ui,Segoe UI,Roboto,Helvetica,Arial";
  // wrap
  const words = text.split(" ");
  let line="", lines=[], test;
  for(const w of words){
    test = line ? (line+" "+w) : w;
    if(ctx.measureText(test).width > maxW){ lines.push(line); line=w; }
    else line=test;
  }
  if(line) lines.push(line);
  const w = Math.min(maxW, Math.max(40, ...lines.map(l=>ctx.measureText(l).width))) + pad*2;
  const h = lines.length*16 + pad*2;
  const bx = Math.round(x - w/2), by = Math.round(y - 46 - h);
  ctx.fillStyle="rgba(15,18,32,0.95)";
  ctx.strokeStyle="rgba(255,255,255,0.85)";
  ctx.lineWidth=2;
  roundRect(ctx, bx, by, w, h, r); ctx.fill(); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x-6, by+h); ctx.lineTo(x+6, by+h); ctx.lineTo(x, by+h+8); ctx.closePath(); ctx.fill(); ctx.stroke();
  ctx.fillStyle="#eaf2ff"; lines.forEach((l,i)=> ctx.fillText(l, bx+pad, by+pad+12 + i*16));
  ctx.restore();
}
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

/* ============================ Best Score =============================== */
function saveBest(){
  const key="best:"+level;
  const prev = +localStorage.getItem(key)||0;
  if(score>prev) localStorage.setItem(key, score);
  ui.best.textContent = Math.max(score,prev);
  ui.bestLevel.textContent = level;
}

/* ============================ Entities ================================= */
function effectiveSkinForLevel(lvl){
  if(lvl==="grocery") return "M1walk.png";
  if(lvl==="office")  return pick(["M2walk.png","M3walk.png"]);
  return skin;
}

async function createPlayer(skinFile){
  const g = await SpriteGrid("Assets/"+skinFile);
  const a = new Animator(g,10); a.dir="right";
  return {
    x:120,y:canvas.height*0.62,scale:1,anim:a,
    hp:100,maxHp:100, st:150,maxSt:150, regen:28,
    lives:3, maxLives:5, inv:0, shield:0, cheap:0, tri:0, costMul:1.0,
    update(dt){
      const up=keys["KeyW"]||keys["ArrowUp"], dn=keys["KeyS"]||keys["ArrowDown"];
      const lf=keys["KeyA"]||keys["ArrowLeft"], rt=keys["KeyD"]||keys["ArrowRight"];
      let vx=(rt?1:0)-(lf?1:0), vy=(dn?1:0)-(up?1:0);
      if(vx||vy){ [vx,vy]=nrm(vx,vy); }
      const sp=240;
      this.x += vx*sp*dt; this.y += vy*sp*dt;
      const pb=playerBox(), cl=clampRect(this.x,this.y,pb); this.x=cl.x; this.y=cl.y;
      if(Math.abs(vx)>Math.abs(vy)) this.anim.dir = vx>=0?"right":"left";
      else if(Math.abs(vy)>0.01)    this.anim.dir = vy>=0?"down":"up";
      this.inv = Math.max(0,this.inv-dt); this.shield=Math.max(0,this.shield-dt);
      this.cheap=Math.max(0,this.cheap-dt); this.tri=Math.max(0,this.tri-dt);
      this.costMul = this.cheap>0 ? 0.6 : 1.0;
      this.st = Math.min(this.maxSt, this.st + this.regen*dt);
      const moving=(vx||vy); this.anim.state=moving?"walk":"idle"; this.anim.speed=moving?sp:0;
      this.anim.update(dt);
    },
    draw(){
      if(this.inv>0){ ctx.save(); ctx.globalAlpha=0.55 + 0.45*Math.sin(performance.now()/50); this.anim.draw(ctx,this.x,this.y,this.scale); ctx.restore(); }
      else this.anim.draw(ctx,this.x,this.y,this.scale);
      if(this.shield>0){ ctx.save(); ctx.strokeStyle="#7dd3fc"; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(this.x,this.y-12,28,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
      if(this.speech?.t>0){ drawBubble(this.x, this.y-28, this.speech.text); this.speech.t-=delta; }
    }
  };
}

function bossKey(lvl){ return "bossSheet:"+lvl; }

async function createBoss(){
  const pool = POOLS[level];
  let url = localStorage.getItem(bossKey(level));
  if(!url || !pool.includes(url)){ url = pick(pool); localStorage.setItem(bossKey(level),url); }

  const g = await SpriteGrid("Assets/"+url);
  const a = new Animator(g,10); a.dir="left";
  const scale = (level==="office") ? 3.2 : 3.0;
  const colR  = 18 * scale;
  const hp    = Math.round(700 * parseFloat(ui.hp.value));
  ui.boss.textContent = url; ui.scale.textContent = scale.toFixed(2)+"Ã—";

  // chaotic movement
  let patTimer = 0, pattern="orbit", dashCD=0, ang=Math.random()*Math.PI*2;
  let targetV  = {vx:-60, vy:0};
  function choosePattern(){ pattern = pick(["orbit","figure8","stripes","zigzag","swoop","dash"]); patTimer = 2.2 + Math.random()*2.0; ang = Math.random()*Math.PI*2; }
  const bb=bossBox();

  const b = {
    url, x: lerp(bb.l,bb.r,0.85), y: lerp(bb.t,bb.b,0.5), vx:-70, vy:0, scale, colR, anim:a,
    hp, maxHp:hp, throwCD:0.9, enrCD:0.35,
    update(dt){
      patTimer -= dt; if(patTimer<=0) choosePattern();
      const base=120; ang += dt*(0.8+Math.random()*0.7);
      if(pattern==="orbit"){ const cx=lerp(bb.l,bb.r,0.65), cy=lerp(bb.t,bb.b,0.5); const toC=[cx-this.x, cy-this.y]; const [nx,ny]=nrm(...toC); targetV.vx = -ny*base*1.1 - 30; targetV.vy = nx*base*1.1; }
      else if(pattern==="figure8"){ targetV.vx = Math.cos(ang)*base*0.9 - 30; targetV.vy = Math.sin(ang*2)*base*0.6; }
      else if(pattern==="stripes"){ targetV.vx = -base*(0.6+0.3*Math.sin(ang*1.5)); targetV.vy = base*Math.sin(ang*2.3)*0.9; }
      else if(pattern==="zigzag"){ targetV.vx = -base*(0.8+0.2*Math.sin(ang*3.0)); targetV.vy = base*Math.sign(Math.sin(ang*2.2))*120; }
      else if(pattern==="swoop"){ targetV.vx = -base*(0.7+0.4*Math.sin(ang*1.7)); targetV.vy = base*Math.sin(ang)*1.2; }
      else if(pattern==="dash"){ dashCD -= dt; if(dashCD<=0){ dashCD = 0.6+Math.random()*0.8; const dirY=(Math.random()<0.5?-1:1); targetV.vx=-260-Math.random()*160; targetV.vy=dirY*(140+Math.random()*120);} }
      this.vx = lerp(this.vx, targetV.vx, 0.12); this.vy = lerp(this.vy, targetV.vy, 0.12);
      this.x += this.vx*dt; this.y += this.vy*dt;
      if(this.x<bb.l){ this.x=bb.l; this.vx=Math.abs(this.vx)*0.85; }
      if(this.x>bb.r){ this.x=bb.r; this.vx=-Math.abs(this.vx)*0.85; }
      if(this.y<bb.t){ this.y=bb.t; this.vy=Math.abs(this.vy)*0.85; }
      if(this.y>bb.b){ this.y=bb.b; this.vy=-Math.abs(this.vy)*0.85; }
      if(Math.abs(this.vx)>Math.abs(this.vy)) this.anim.dir = (this.vx>=0)?"right":"left"; else this.anim.dir = (this.vy>=0)?"down":"up";
      const sp=Math.hypot(this.vx,this.vy); this.anim.state = this.hp<=this.maxHp*0.15? "dash" : (sp>5?"walk":"idle"); this.anim.speed=sp; this.anim.update(dt);

      // office barrages + boss lines
      if(level==="office"){
        this.throwCD -= dt;
        if(this.throwCD<=0){
          this.throwCD = 0.55 + Math.random()*0.4;
          const shots = 1 + (Math.random()<0.5?1:0);
          for(let i=0;i<shots;i++){ const spec=pick(OFFICE_BOSS_EMOJI); spawnEnemyEmoji(this.x-30, this.y+rand(-36,36), spec.ch, spec.speed, player.x, player.y+rand(-18,18), spec.damage); }
          if(Math.random()<0.35) say(this, pick(LINES[level]));
        }
        if(this.hp <= this.maxHp*0.15){
          this.enrCD -= dt;
          if(this.enrCD<=0){ this.enrCD=0.22; const spec=pick(OFFICE_BOSS_EMOJI); spawnEnemyEmoji(this.x-30, this.y+rand(-36,36), spec.ch, spec.speed+80, player.x, player.y, spec.damage+4); if(Math.random()<0.5) say(this, pick(LINES.bossLow)); }
        }
      }
    },
    draw(){
      const x=canvas.width-300, y=20, w=270, h=10;
      ctx.fillStyle="#142034"; ctx.fillRect(x-2,y-2,w+4,h+4);
      ctx.fillStyle="#0b1220"; ctx.fillRect(x,y,w,h);
      ctx.fillStyle=(this.hp/this.maxHp<0.15)?"#f59e0b":"#ef4444"; ctx.fillRect(x,y,w*(this.hp/this.maxHp),h);
      this.anim.draw(ctx,this.x,this.y,this.scale);
      if(this.speech?.t>0){ drawBubble(this.x, this.y-28, this.speech.text); this.speech.t-=delta; }
    },
    hit(dmg){ this.hp=Math.max(0,this.hp-dmg); this.anim.freeze=0.1; if(Math.random()<0.4) say(this, pick(LINES.bossLow)); }
  };
  say(b, pick(LINES[level]||LINES.coffee)); // opener
  choosePattern();
  return b;
}

async function spawnEnemy(){
  const url = pick(POOLS[level]);
  const g=await SpriteGrid("Assets/"+url); const a=new Animator(g,10); a.dir="left";
  const pattern = pick(["straight","zigzag","swoop","dasher"]);
  const speed = rand(120,180);
  const hp = Math.round(rand(40,70)*parseFloat(ui.hp.value));
  const e = {
    x:canvas.width+40,y:rand(120,canvas.height-50), vx:-speed, vy:0, scale:1.14, anim:a,
    hp,maxHp:hp,t:0,pattern, throwCD:rand(0.9,1.8), bodyDmg:10, colR:22, talkTimer:rand(1.2,2.6),
    update(dt){
      this.t+=dt; this.talkTimer -= dt;
      if(this.pattern==="zigzag"){ this.vy=Math.sin(this.t*4)*90; }
      else if(this.pattern==="swoop"){ this.vy=Math.sin(this.t*2.2 + this.y*0.005)*70; this.vx=-speed*(0.75+0.25*Math.sin(this.t*1.7)); }
      else if(this.pattern==="dasher"){ this.vx=-speed*(1.0+0.75*(Math.sin(this.t*3.0)>0?1:0)); }
      this.x+=this.vx*dt; this.y=clamp(this.y+this.vy*dt,110,canvas.height-50);

      // periodic minion chatter (guaranteed bubbles, TTS throttled)
      if(this.talkTimer<=0){ this.talkTimer = rand(3.5,6.0); say(this, pick(LINES[level]||LINES.coffee)); }

      // throws + line (on throw)
      this.throwCD -= dt;
      if(this.throwCD<=0){
        this.throwCD = rand(1.0,2.2);
        const ch = pick(MINION_EMOJI);
        spawnEnemyEmoji(this.x-24, this.y+rand(-18,18), ch, rand(360,440), player.x, player.y+rand(-14,14), 8);
        if(Math.random()<0.65) say(this, pick(LINES[level]||LINES.coffee));
      }

      this.anim.state="walk"; this.anim.speed=Math.hypot(this.vx,this.vy); this.anim.update(dt);
      if(this.x<-80 || this.hp<=0) this.dead=true;
    },
    draw(){ this.anim.draw(ctx,this.x,this.y,this.scale); if(this.speech?.t>0){ drawBubble(this.x, this.y-24, this.speech.text); this.speech.t-=delta; } }
  };
  // spawn-time line (higher chance so it's noticeable)
  if(Math.random()<0.7) say(e, pick(LINES[level]||LINES.coffee), 2.5);
  enemies.push(e);
}

/* ============================ Projectiles =============================== */
function throwPlayer(){
  const spec = PLAYER_EMOJI[level]; if(!spec) return;
  const cost = spec.stamina * player.costMul;
  if(player.st < cost) return;
  player.st -= cost; sfxThrow();
  const makeShot = (vy)=>({ ch:spec.ch, friendly:true, x:player.x+28, y:player.y-18, vx:spec.speed, vy, r:14, dmg:spec.damage, life:2.4 });
  if(player.tri>0){ playerShots.push(makeShot(-120), makeShot(0), makeShot(120)); }
  else { playerShots.push(makeShot(0)); }
}

function spawnEnemyEmoji(x,y,ch,speed,tx,ty,damage){
  const dx=tx-x, dy=ty-y, len=Math.hypot(dx,dy)||1;
  const vx=dx/len*speed, vy=dy/len*speed;
  enemyShots.push({ ch, friendly:false, x,y, vx,vy, r:14, dmg:damage||10, life:3.0,
    update(dt){ this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dt; },
    draw(){ drawEmoji(this.ch,this.x,this.y,28); }
  });
}

/* ============================ Props ==================================== */
function buildProps(){
  props.length = 0;
  if(level==="grocery"){ for(let y=180;y<=540;y+=120) props.push({type:"cone",x:canvas.width*0.55,y,r:18}); }
  if(level==="parking"){ for(let y=220;y<=520;y+=150) props.push({type:"cone",x:canvas.width*0.60,y,r:18}); for(let y=160;y<=560;y+=100) props.push({type:"mailbox",x:canvas.width*0.40,y,r:20}); }
  if(level==="neighborhood"){ for(let y=160;y<=560;y+=100) props.push({type:"mailbox",x:canvas.width*0.55,y,r:20}); }
  if(level==="office"){ props.push({type:"cooler",x:canvas.width*0.35,y:canvas.height*0.65,r:22,cool:0}); props.push({type:"mailbox",x:canvas.width*0.50,y:canvas.height*0.45,r:20}); }
}
function drawProps(){
  for(const p of props){
    if(p.type==="cone"){ ctx.save(); ctx.translate(p.x,p.y); ctx.fillStyle="#ff7a00"; ctx.beginPath(); ctx.moveTo(-10,12); ctx.lineTo(10,12); ctx.lineTo(0,-14); ctx.closePath(); ctx.fill(); ctx.fillStyle="#fff"; ctx.fillRect(-8,2,16,3); ctx.restore(); }
    if(p.type==="mailbox"){ ctx.save(); ctx.translate(p.x,p.y); ctx.fillStyle="#2b5dab"; ctx.fillRect(-14,-12,28,24); ctx.fillStyle="#173055"; ctx.fillRect(-14,0,28,3); ctx.restore(); }
    if(p.type==="cooler"){ ctx.save(); ctx.translate(p.x,p.y); ctx.fillStyle="#8dd1ff"; ctx.fillRect(-14,-18,28,36); ctx.fillStyle="#cdefff"; ctx.fillRect(-12,-16,24,20); ctx.restore(); }
  }
}
function handleProps(dt){
  for(const e of enemies){
    for(const p of props){
      if(p.type==="cone" && hitCircle(e.x,e.y-10,e.colR||20, p.x,p.y, p.r)){ e.vy = (e.y<p.y?-1:1)*rand(120,180); e.y += e.vy*dt; }
    }
  }
  const allProj=[...playerShots, ...enemyShots];
  for(const p of props){
    if(p.type==="mailbox"){
      for(const pr of allProj){ if(hitCircle(pr.x,pr.y,12, p.x,p.y,p.r)){ pr.vx *= -1; pr.x += pr.vx*0.02; } }
    } else if(p.type==="cooler"){
      p.cool -= dt;
      if(p.cool<=0 && hitCircle(player.x,player.y-10,22, p.x,p.y,p.r+8)){ player.hp=Math.min(player.maxHp, player.hp+10); player.st=Math.min(player.maxSt,player.st+40); p.cool=6.0; }
    }
  }
}

/* ============================ Powerups ================================= */
const POWERUP_TYPES = [
  {type:"shield",ch:"ðŸ›¡ï¸", dur:6},
  {type:"life",  ch:"â¤ï¸"},
  {type:"stam",  ch:"â˜•",  amt:50},
  {type:"cheap", ch:"âš¡", dur:10},
  {type:"tri",   ch:"âœ¨", dur:10}
];
function spawnPowerup(){
  const spec=pick(POWERUP_TYPES);
  powerups.push({ ...spec, x:canvas.width+30, y:rand(140,canvas.height-60), vx:-140, vy:rand(-20,20), life:10 });
}
function updatePowerups(dt){
  powerTimer -= dt;
  if(powerTimer<=0){ powerTimer = rand(9,14); spawnPowerup(); }
  for(const p of powerups){
    p.x += p.vx*dt; p.y = clamp(p.y + p.vy*dt, 120, canvas.height-50); p.life -= dt;
    if(hitCircle(player.x,player.y-10,24, p.x,p.y,18)){ applyPowerup(p); p.life=0; sfxPup(); }
  }
  powerups = powerups.filter(p=>p.life>0 && p.x>-60);
}
function drawPowerups(){ for(const p of powerups){ drawEmoji(p.ch,p.x,p.y,30); } }
function applyPowerup(p){
  if(p.type==="shield"){ player.shield = Math.max(player.shield, p.dur||6); }
  else if(p.type==="life"){ player.lives = Math.min(player.maxLives, player.lives+1); }
  else if(p.type==="stam"){ player.st = Math.min(player.maxSt, player.st + (p.amt||50)); }
  else if(p.type==="cheap"){ player.cheap = Math.max(player.cheap, p.dur||10); }
  else if(p.type==="tri"){ player.tri = Math.max(player.tri, p.dur||10); }
}

/* ============================ Bars & BG ================================= */
function drawBars(){
  ctx.fillStyle="#fff"; ctx.font="12px system-ui";
  const x=20,y=18,w=240,h=12;
  ctx.fillStyle="#0b1020"; ctx.fillRect(x-2,y-2,w+4,h+4);
  ctx.fillStyle="#0b1220"; ctx.fillRect(x,y,w,h);
  ctx.fillStyle= player.inv>0||player.shield>0 ? "#60a5fa" : "#ef4444"; ctx.fillRect(x,y,w*(player.hp/player.maxHp),h);
  ctx.fillStyle="#fff"; ctx.fillText("Health",x,y-6);
  const y2=y+22;
  ctx.fillStyle="#0b1020"; ctx.fillRect(x-2,y2-2,w+4,h+4); ctx.fillStyle="#0b1220"; ctx.fillRect(x,y2,w,h);
  ctx.fillStyle="#22c55e"; ctx.fillRect(x,y2,w*(player.st/player.maxSt),h); ctx.fillStyle="#fff"; ctx.fillText("Stamina",x,y2-6);
  ui.lives.textContent = player.lives;
  const act=[]; if(player.shield>0)act.push(`ðŸ›¡ï¸${player.shield.toFixed(0)}s`); if(player.cheap>0)act.push(`âš¡${player.cheap.toFixed(0)}s`); if(player.tri>0)act.push(`âœ¨${player.tri.toFixed(0)}s`);
  ui.pwr.textContent = act.length?act.join("  â€¢  "):"â€”";
  ctx.fillStyle="#111827"; ctx.fillRect(20,y2+24,160,20); ctx.fillStyle="#69e7c3"; ctx.fillText("Score: "+score,26,y2+38);
}
function drawBackground(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle="#d2d7e2"; ctx.lineWidth=2; ctx.globalAlpha=.6;
  for(let y=110;y<canvas.height;y+=80){ ctx.beginPath(); ctx.moveTo(40,y); ctx.lineTo(canvas.width-40,y); ctx.stroke(); }
  ctx.globalAlpha=1;
}

/* ============================ Damage / collisions ======================= */
function damagePlayer(amount){
  if(player.shield>0 || player.inv>0) return;
  const mult=parseFloat(ui.dmg.value);
  player.hp = Math.max(0, player.hp - amount*mult);
}

/* ============================ Loop ===================================== */
let spawnBase = 1.3;
let last=performance.now();
async function loop(now=performance.now()){
  delta = Math.min(0.033,(now-last)/1000); last=now;

  if(!paused){
    // spawn controller
    spawnTimer -= delta;
    const slider = parseFloat(ui.spawn.value);
    const nextEvery = spawnBase / slider;
    if(spawnTimer<=0 && needBoss){ spawnTimer = nextEvery; spawnEnemy(); }

    // global crowd chatter (pick a random on-screen minion now and then)
    crowdChatterTimer -= delta;
    if(crowdChatterTimer<=0 && enemies.length){
      crowdChatterTimer = rand(3.5,6.0);
      const e = pick(enemies);
      if(e && !e.dead) say(e, pick(LINES[level]||LINES.coffee));
    }

    // powerups
    updatePowerups(delta);

    // input
    if(keys["Space"]){ keys["Space"]=false; throwPlayer(); }

    // update entities
    player && player.update(delta);
    enemies.forEach(e=>e.update(delta));
    playerShots.forEach(p=>{ p.x+=p.vx*delta; p.y+=p.vy*delta; p.life-=delta; });
    enemyShots.forEach(p=>p.update(delta));
    boss && boss.update(delta);
    handleProps(delta);

    // collisions
    for(const p of playerShots){
      for(const e of enemies){
        if(!e.dead && e.hp>0 && hitCircle(p.x,p.y,p.r, e.x,e.y-16,e.colR)){ e.hp-=p.dmg; p.life=0; sfxHit(); if(e.hp<=0){ e.dead=true; kills++; score+=25; if(Math.random()<0.35) say(e, pick(LINES.onDefeat)); } }
      }
      if(boss && boss.hp>0 && hitCircle(p.x,p.y,p.r, boss.x,boss.y-24,boss.colR)){ boss.hit(p.dmg); p.life=0; sfxHit(); score+=15; }
    }
    for(const p of enemyShots){ if(hitCircle(p.x,p.y,p.r, player.x,player.y-18,22)){ damagePlayer(p.dmg); p.life=0; sfxHit(); } }
    for(const e of enemies){ if(!e.dead && hitCircle(player.x,player.y-10,22, e.x,e.y-10,e.colR)){ damagePlayer(e.bodyDmg); e.dead=true; sfxHit(); } }

    enemies = enemies.filter(e=>!e.dead && e.x>-80 && e.hp>0);
    playerShots = playerShots.filter(p=>p.life>0 && p.x<canvas.width+40);
    enemyShots  = enemyShots.filter(p=>p.life>0 && p.x>-60 && p.x<canvas.width+60 && p.y>60 && p.y<canvas.height-10);

    if(needBoss && kills>=16){ needBoss=false; boss = await createBoss(); }

    if(player.hp<=0){
      if(player.lives>0){ player.lives -= 1; player.hp=player.maxHp; player.st=player.maxSt; player.inv=2.5; say(player,"Not today!",1.8); }
      else { paused=true; saveBest(); TTS.stop(); titleHeading.textContent="Defeat â€” Press Play"; titleOverlay.style.display="flex"; }
    }
    if(!needBoss && boss && boss.hp<=0){ paused=true; score+=300; saveBest(); TTS.stop(); say(boss, pick(LINES.onDefeat)); titleHeading.textContent="Victory â€” Choose another level"; titleOverlay.style.display="flex"; }
  }

  drawBackground(); drawProps(); drawPowerups();
  player && player.draw();
  enemies.forEach(e=>e.draw());
  playerShots.forEach(p=>drawEmoji(p.ch,p.x,p.y,28));
  enemyShots.forEach(p=>p.draw());
  boss && boss.draw();
  drawBars();

  ui.score.textContent = score;
  requestAnimationFrame(loop);
}

/* ============================ Boot / UI ================================ */
async function boot(lvl){
  TTS.stop();
  level=lvl; ui.level.textContent=lvl; localStorage.setItem("lastLevel", lvl);
  enemies.length=0; playerShots.length=0; enemyShots.length=0; props.length=0; powerups.length=0;
  kills=0; needBoss=true; spawnTimer=0.2; powerTimer=rand(4,8); score=0; crowdChatterTimer = rand(2.5,4.5);
  const lvlSkin = effectiveSkinForLevel(level);
  player = await createPlayer(lvlSkin);
  document.querySelectorAll(".skin").forEach(c=> c.classList.toggle("sel", c.dataset.skin===lvlSkin));
  boss = null;
  buildProps();
  ui.best.textContent = +localStorage.getItem("best:"+level)||0; ui.bestLevel.textContent = level; ui.lives.textContent = player.lives;
}
function hideTitle(){ titleOverlay.style.display="none"; initAudio(); }

document.getElementById("titlePlay").onclick = async ()=>{ hideTitle(); TTS.stop(); paused=false; await boot(level); };
document.getElementById("btnPlay").onclick  = async ()=>{ hideTitle(); TTS.stop(); paused=false; if(!player) await boot(level); };
document.getElementById("btnPause").onclick = ()=>{ paused=true; TTS.stop(); };
document.getElementById("btnResetBoss").onclick = ()=>{ Object.keys(POOLS).forEach(k=>localStorage.removeItem(bossKey(k))); ui.boss.textContent="â€”"; };

document.querySelectorAll(".lvl").forEach(b=> b.addEventListener("click", async ()=>{ hideTitle(); TTS.stop(); paused=false; await boot(b.dataset.lvl); }));
document.querySelectorAll(".skin").forEach(chip=>{
  chip.addEventListener("click", async ()=>{
    document.querySelectorAll(".skin").forEach(c=>c.classList.remove("sel"));
    chip.classList.add("sel");
    skin = chip.dataset.skin; localStorage.setItem("playerSkin", skin);
    await boot(level);
  });
});
(function restoreSkin(){ document.querySelectorAll(".skin").forEach(c=>{ if(c.dataset.skin===skin) c.classList.add("sel"); else c.classList.remove("sel"); }); })();

document.getElementById("toggleVoices").onclick = ()=>{ voicesOn=!voicesOn; if (!voicesOn) TTS.stop(); ui.vState.textContent=voicesOn?"On":"Off"; };
document.getElementById("toggleSfx").onclick    = ()=>{ sfxOn=!sfxOn; ui.sState.textContent=sfxOn?"On":"Off"; };

(async function start(){ await boot(level); requestAnimationFrame(loop); })();
</script>
</body>
</html>
