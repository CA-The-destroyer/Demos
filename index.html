<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Karen Crashout â€” DX+ (robust audio, splash, universal boss attacks)</title>

<!-- Preload splash music for instant start -->
<link rel="preload" as="audio" href="Assets/splash_screen.mp3" type="audio/mpeg" crossorigin="anonymous">

<style>
  :root { --bg:#efe9dc; --panel:#0d1328; --ink:#e6eeff; --muted:#9fb0d8; --btn:#1a2143; --btnH:#232d58; --cy:#69e7c3; }
  html,body{height:100%;margin:0;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  body{display:grid;grid-template-columns:360px 1fr;background:var(--bg)}
  #ui{background:var(--panel);color:var(--ink);padding:14px;overflow:auto;box-shadow:inset -1px 0 0 rgba(255,255,255,.06)}
  h1{margin:0 0 8px;font-size:20px}
  small{color:var(--muted)}
  .row{margin:10px 0}
  .btn{display:inline-block;background:var(--btn);color:#eaf2ff;padding:8px 12px;border-radius:10px;cursor:pointer;user-select:none;margin:4px 6px 0 0}
  .btn:hover{background:var(--btnH)}
  .chip{display:inline-block;padding:5px 9px;border-radius:999px;background:#1c244a;margin:2px 6px 0 0}
  .sel{outline:2px solid var(--cy)}
  .slider{width:100%}
  .kv{font-family:ui-monospace,Consolas,Menlo,monospace}
  canvas{width:100%;height:100%;display:block;background:#10131a}

  .title{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(7,9,16,.72);z-index:7}
  .card{background:#0b1022cc;color:#cfe0ff;width:min(920px,92vw);padding:22px;border-radius:16px;box-shadow:0 12px 50px rgba(0,0,0,.45)}
  .pill{background:#182045;border-radius:999px;padding:6px 10px;margin-right:6px;display:inline-block}
  .title::before{
    content:""; position:absolute; inset:0; z-index:-1;
    background:#111 url(Assets/Karen_Crashout_splash.png) center/cover no-repeat;
    filter:saturate(1.08) brightness(.9);
  }
</style>
</head>
<body>

<!-- LEFT PANEL -->
<div id="ui">
  <h1>Karen Crashout</h1>
  <small>Robust music â€¢ Splash plays reliably â€¢ All bosses attack â€¢ ðŸ’© critical at 20%</small>

  <div class="row">
    <span class="btn" id="btnPlay">Play</span>
    <span class="btn" id="btnPause">Pause</span>
    <span class="btn" id="btnResetBoss">Reset Boss Picks</span>
  </div>

  <div class="row">
    <strong>Level</strong><br>
    <span class="btn lvl" data-lvl="coffee">Coffee Shop</span>
    <span class="btn lvl" data-lvl="grocery">Grocery</span>
    <span class="btn lvl" data-lvl="parking">Parking Lot</span>
    <span class="btn lvl" data-lvl="neighborhood">Neighborhood</span>
    <span class="btn lvl" data-lvl="office">Office (blonde boss)</span>
  </div>

  <div class="row">
    <strong>Player Skin (default)</strong><br>
    <span class="chip skin sel" data-skin="M1walk.png">M1</span>
    <span class="chip skin" data-skin="M2walk.png">M2</span>
    <span class="chip skin" data-skin="M3walk.png">M3</span>
    <div style="color:#9fb0d8;margin-top:6px;font-size:12px">
      Grocery forces M1. Office randomly uses M2 or M3 each run.
    </div>
  </div>

  <div class="row">
    <strong>Difficulty</strong><br>
    <label>Spawn Rate (higher = more enemies)</label>
    <input id="spawnRate" class="slider" type="range" min="0.5" max="2.0" step="0.05" value="0.5">
    <label>Enemy HP Multiplier</label>
    <input id="hpMult" class="slider" type="range" min="0.6" max="2.0" step="0.05" value="1.0">
    <label>Player Damage Taken Multiplier</label>
    <input id="dmgMult" class="slider" type="range" min="0.5" max="2.0" step="0.05" value="1.0">
  </div>

  <div class="row">
    <strong>Audio</strong><br>
    <span class="chip" id="toggleVoices">Voices: <span id="vState">On</span></span>
    <span class="chip" id="toggleSfx">SFX: <span id="sState">On</span></span>
    <span class="chip" id="toggleMusic">Music: <span id="mState">On</span></span>
  </div>

  <div class="row">
    <strong>Info</strong><br>
    <div>Level: <span id="lblLevel" class="kv">coffee</span></div>
    <div>Boss Sheet: <span id="lblBoss" class="kv">â€”</span></div>
    <div>Boss Scale: <span id="lblScale" class="kv">â€”</span></div>
    <div>Score: <span id="lblScore" class="kv">0</span></div>
    <div>Best (<span id="bestLevel" class="kv">coffee</span>): <span id="lblBest" class="kv">0</span></div>
    <div>Lives: <span id="lblLives" class="kv">3</span></div>
    <div>Powerups: <span id="lblPwr" class="kv">â€”</span></div>
  </div>

  <div class="row"><small>Move: WASD/Arrows â€¢ Throw: Space â€¢ Pause: Esc</small></div>
</div>

<!-- GAME CANVAS -->
<canvas id="game" width="1280" height="720"></canvas>

<!-- TITLE OVERLAY -->
<div id="title" class="title" style="display:flex">
  <div class="card">
    <div id="titleHeading" style="font-size:28px;font-weight:800;margin-bottom:6px">Karen Crashout â€” Click anywhere to start music â€¢ Press Play</div>
    <div class="pill">WASD move</div><div class="pill">Space throw</div><div class="pill">Esc pause</div>
    <div style="margin-top:14px">
      <span class="btn" id="titlePlay">Play</span>
      <span class="btn lvl" data-lvl="coffee">Coffee</span>
      <span class="btn lvl" data-lvl="grocery">Grocery</span>
      <span class="btn lvl" data-lvl="office">Office</span>
    </div>
  </div>
</div>

<script>
/* ============================ CONFIG =================================== */
const PLAYER_SKINS = ["M1walk.png","M2walk.png","M3walk.png"];
const POOLS = {
  coffee:       ["K1walk.png","K3walk.png","K4walk.png"],
  grocery:      ["K1walk.png","K2walk.png","K4walk.png"],
  parking:      ["K1walk.png","K4walk.png"],
  neighborhood: ["K1walk.png","K2walk.png","K3walk.png","K4walk.png"],
  office:       ["K2walk.png","K3walk.png"] // blonde-only pool
};

/* Backgrounds + magic border (block top strip) */
const LEVEL_BG = {
  coffee:       "Assets/Coffee_shop-bkgrnd.png",
  grocery:      "Assets/Grocery-bkgnd.png",
  parking:      "Assets/Parking-bkgnd.png",
  neighborhood: "Assets/Nhood-bkgnd.png",
  office:       "Assets/Office-bkgnd.png"
};
const LEVEL_BAND_Y = { coffee:210, grocery:220, parking:170, neighborhood:240, office:230 };

/* Per-scene visual scale so sprites fit backgrounds */
const SCALE = { coffee:1.75, grocery:1.75, parking:1.85, neighborhood:1.85, office:1.95 };
const BOSS_MULT = 3.0;   // boss size relative to scene scale

/* Scene music */
const TRACKS = {
  splash:       "splash_screen.mp3",             // â† New splash track
  coffee:       "Karen_Glitchy_Groove.mp3",
  grocery:      "Chaos in Aisle Three.mp3",
  parking:      "Parking_Wars.mp3",
  neighborhood: "StrangersStreet.mp3",
  office:       "Queen_of_the_Complaint Line.mp3"
};

/* Player projectile spec by scene */
const PLAYER_EMOJI = {
  coffee:       {ch:"â˜•", stamina:12, speed:560, damage:16},
  grocery:      {ch:"ðŸ›’", stamina:22, speed:480, damage:26},
  parking:      {ch:"ðŸš§", stamina:18, speed:520, damage:20},
  neighborhood: {ch:"ðŸ“°", stamina:10, speed:560, damage:12},
  office:       {ch:"ðŸ“Ž", stamina:14, speed:540, damage:16}
};
const MINION_EMOJI = ["ðŸ’„","ðŸ¬","ðŸ¥¤"];

/* Office boss special */
const OFFICE_BOSS_EMOJI = [
  {ch:"ðŸ´", speed:520, damage:18},
  {ch:"ðŸ”¥", speed:460, damage:22},
  {ch:"ðŸš§", speed:380, damage:16}
];

/* UNIVERSAL BOSS ATTACK CONFIG */
const POO_SPEC = { ch:"ðŸ’©", speed:420, damage:14 }; // critical attack for all bosses
const BOSS_BASE_ATTACKS = {
  coffee:       [{ ch:"â˜•", speed:520, damage:16 }],
  grocery:      [{ ch:"ðŸ›’", speed:460, damage:22 }],
  parking:      [{ ch:"ðŸš§", speed:420, damage:18 }],
  neighborhood: [{ ch:"ðŸ“°", speed:540, damage:14 }],
  office:       OFFICE_BOSS_EMOJI
};

/* Lines */
const LINES = {
  coffee: [
    "I want to talk to your manager!",
    "I need thirty specialty drinks in five minutes!",
    "I ordered nonfat foam-free oat whip â€” do it again!",
    "This coupon never expires â€” it says so!"
  ],
  grocery: [
    "Price match every item, now!",
    "I saw it cheaper online â€” honor it!",
    "Bag it again, properly this time!",
    "I need twelve returns without a receipt."
  ],
  parking: [
    "That spot is mine â€” I was thinking about it!",
    "You can't ticket me â€” I'm special!",
    "Why is this cone in my way?!",
    "Do you know who I am?!"
  ],
  neighborhood: [
    "Your lawn is two inches too high!",
    "Quiet hours begin at 3PM â€” learn it!",
    "I'm calling the HOA right now!",
    "Who approved that mailbox color?"
  ],
  office: [
    "You aren't important enough to matter!",
    "You're stealing from this company â€” I can prove it!",
    "Someone sounds entitled!",
    "No more lunch cards! Why are we paying bonuses?",
    "My lifestyle can't afford what we are paying you!"
  ],
  bossLow:   ["This isn't over!","Security! SE-CUR-I-TY!","Where is your manager?!","You will hear from corporate!"],
  onDefeat:  ["I'm leaving a one-star review!","Unacceptable!","Refund! Refund! Refund!"]
};

/* ============================ UI refs ================================== */
const $ = s => document.querySelector(s);
const ui = {
  level: $("#lblLevel"), boss: $("#lblBoss"), scale: $("#lblScale"),
  score: $("#lblScore"), best: $("#lblBest"), bestLevel: $("#bestLevel"),
  spawn: $("#spawnRate"), hp: $("#hpMult"), dmg: $("#dmgMult"),
  vState: $("#vState"), sState: $("#sState"), mState: $("#mState"), lives: $("#lblLives"), pwr: $("#lblPwr")
};
const titleOverlay = $("#title");
const titleHeading = $("#titleHeading");

/* ============================ Input ==================================== */
const keys = Object.create(null);
addEventListener("keydown", e=>{ keys[e.code]=true; if(e.code==="Escape") paused=!paused; });
addEventListener("keyup",   e=>{ keys[e.code]=false; });

/* ============================ Audio (WebAudio) ========================= */
let voicesOn = true, sfxOn = true, musicOn = true, ac;
let femaleVoices = [];
function initAudio(){ try{ ac = ac || new (window.AudioContext||window.webkitAudioContext)(); if(ac.state==="suspended") ac.resume(); }catch(e){} }

function refreshVoices(){
  femaleVoices = [];
  try { const list=speechSynthesis.getVoices()||[]; femaleVoices=list.filter(v=>/female|woman|samantha|victoria|zira|karen|espeakf/i.test((v.name||"")+(v.lang||""))); } catch(e){}
}
if("speechSynthesis" in window){ speechSynthesis.onvoiceschanged=refreshVoices; refreshVoices(); }

/* -------- Robust BGM engine: cache + watchdog + safe switch ---------- */
const BGM = {
  cur:null, curGain:null, curName:null,
  cache:new Map(),

  async _load(url){
    initAudio();
    if (this.cache.has(url)) return this.cache.get(url);
    const res = await fetch(encodeURI("Assets/"+url), { cache: "force-cache" });
    const buf = await res.arrayBuffer();
    const audio = await ac.decodeAudioData(buf);
    this.cache.set(url, audio);
    return audio;
  },

  async switchTo(name, fade=0.8){
    if (!musicOn) return;
    initAudio();
    if (!name) return;

    // already playing requested track? just ensure audible
    if (this.curName === name && this.cur) {
      try { if (ac.state !== "running") await ac.resume(); } catch(e){}
      if (this.curGain) this.curGain.gain.value = 0.4;
      return;
    }

    const url = TRACKS[name] || TRACKS.coffee;
    try{
      const buf = await this._load(url);
      const src = ac.createBufferSource(); src.buffer=buf; src.loop=true;
      const g = ac.createGain(); g.gain.value=0.0001; src.connect(g).connect(ac.destination);
      src.start();

      // fade out old
      if (this.cur && this.curGain){
        const og=this.curGain;
        try{
          og.gain.cancelScheduledValues(ac.currentTime);
          og.gain.setTargetAtTime(0.0001, ac.currentTime, fade);
          setTimeout(()=>{ try{ this.cur.stop(); this.cur.disconnect(); }catch(e){} }, fade*1000*3);
        }catch(e){}
      }

      // fade in new
      g.gain.cancelScheduledValues(ac.currentTime);
      g.gain.setTargetAtTime(0.4, ac.currentTime+0.02, fade);

      this.cur = src; this.curGain = g; this.curName = name;
    }catch(e){
      // keep game running even if audio fails
    }
  },

  ensure(){
    if (!musicOn) return;
    if (!ac) initAudio();
    if (ac && ac.state !== "running") { ac.resume().catch(()=>{}); }
    if (!this.cur && this.curName) { this.switchTo(this.curName); }
  },

  stop(){
    try { if (this.cur){ this.cur.stop(); this.cur.disconnect(); } } catch(e){}
    this.cur=null; this.curGain=null; this.curName=null;
  }
};

// Music watchdog: recover from suspended AudioContext (tab switch / mobile)
setInterval(()=>BGM.ensure(), 3500);

// Arm splash music on the very first user gesture anywhere (capture + once)
function armSplashOnce(){ initAudio(); if (musicOn) BGM.switchTo("splash"); }
window.addEventListener("pointerdown", armSplashOnce, { once:true, capture:true });

document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ try{ speechSynthesis.cancel(); }catch(e){} }});
const TTS = {
  busy:false, bossUntil:0, utter:null,
  speak(line, channel="enemy"){
    if(!voicesOn || !("speechSynthesis" in window)) return;
    const now=performance.now();
    if(channel==="boss"){ try{ speechSynthesis.cancel(); }catch(e){} this.busy=false; this.bossUntil=now+800; }
    else if(this.busy || now<this.bossUntil){ return; }
    const u=new SpeechSynthesisUtterance(line); const v=femaleVoices[0]; if(v) u.voice=v; u.pitch=1.6; u.rate=1.25; u.volume=0.9;
    u.onstart=()=>this.busy=true; const done=()=>{this.busy=false; this.utter=null;}; u.onend=done; u.onerror=done;
    this.utter=u; try{ speechSynthesis.speak(u);}catch(e){ done(); }
  },
  stop(){ try{ if("speechSynthesis" in window) speechSynthesis.cancel(); }catch(e){} this.busy=false; this.utter=null; this.bossUntil=0; }
};
function sfx(freq=880, dur=0.07, gain=0.08, type="square"){ if(!sfxOn) return; initAudio(); const o=ac.createOscillator(), g=ac.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=gain; g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime+dur); o.connect(g).connect(ac.destination); o.start(); o.stop(ac.currentTime+dur); }
const sfxThrow = ()=>sfx(1200,0.07,0.08,"square");
const sfxHit   = ()=>sfx(220,0.09,0.10,"sawtooth");
const sfxPup   = ()=>sfx(980,0.12,0.12,"triangle");

/* ============================ Sprites ================================== */
function loadImage2(url){ return new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=url; }); }
const ROW_MAP = { up:0, left:1, down:2, right:3 };
async function SpriteGrid(url){
  const img=await loadImage2(url); const rows=4, fh=Math.floor(img.height/rows), fw=fh, cols=Math.floor(img.width/fw);
  return { img, fw, fh, cols,
    rect(dir,frame){ const r=(ROW_MAP[dir]??0), c=frame%cols; return {sx:c*fw, sy:r*fh, sw:fw, sh:fh}; },
    draw(ctx,x,y,dir,frame,scale=1){ const {sx,sy,sw,sh}=this.rect(dir,frame); const dw=sw*scale, dh=sh*scale; ctx.drawImage(this.img,sx,sy,sw,sh, Math.round(x-dw/2), Math.round(y-dh), Math.round(dw), Math.round(dh)); }
  };
}
class Animator{
  constructor(grid,fps=10){ this.g=grid; this.fps=fps; this.acc=0; this.frame=0; this.dir="left"; this.state="idle"; this.speed=0; this.freeze=0; }
  update(dt){ if(this.freeze>0){ this.freeze-=dt; return; } const mul=this.state==="dash"?2.0:this.state==="walk"?(0.55+Math.min(1.6,this.speed/160)):0.6; const fps=this.fps*mul; this.acc+=dt*fps; while(this.acc>=1){ this.frame=(this.frame+1)%this.g.cols; this.acc-=1; } }
  draw(ctx,x,y,scale=1){ const idle=(this.g.cols>=8?4:0); const f=this.state==="idle"?idle:this.frame; this.g.draw(ctx,x,y,this.dir,f,scale); }
}
const lerp=(a,b,t)=>a+(b-a)*Math.max(0,Math.min(1,t));
function clampRect(x,y,box){ return { x: Math.max(box.l, Math.min(box.r, x)), y: Math.max(box.t, Math.min(box.b, y)) }; }
function len2(vx,vy){ return Math.hypot(vx,vy)||1; }
function nrm(vx,vy){ const L=len2(vx,vy); return [vx/L,vy/L]; }

/* Magic border */
let PLAY_TOP=110;
const canvas=document.getElementById("game"); const ctx=canvas.getContext("2d");
function playerBox(){ return { l:60, r:Math.floor(canvas.width*0.48), t:PLAY_TOP+20, b:canvas.height-40 }; }
function bossBox(){ return { l:Math.floor(canvas.width*0.55), r:canvas.width-60, t:PLAY_TOP+20, b:canvas.height-40 }; }

let level=localStorage.getItem("lastLevel")||"coffee";
let skin =localStorage.getItem("playerSkin")||"M1walk.png";
let paused = true; // start paused to allow splash to play

let player=null,boss=null; let enemies=[],playerShots=[],enemyShots=[],props=[],powerups=[];
let kills=0,needBoss=true,spawnTimer=0,powerTimer=0,score=0,crowdChatterTimer=3.5;
let bgImg=null; async function loadBG(lvl){ bgImg=await loadImage2(LEVEL_BG[lvl]); }
const rand=(a,b)=>a+Math.random()*(b-a); const pick=arr=>arr[(Math.random()*arr.length)|0];
function drawEmoji(ch,x,y,size){ ctx.save(); ctx.font=`bold ${size}px "Segoe UI Emoji","Apple Color Emoji","Noto Color Emoji",sans-serif`; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.shadowColor="rgba(0,0,0,.25)"; ctx.shadowBlur=4; ctx.fillText(ch,x,y); ctx.restore(); }
function hitCircle(ax,ay,ar,bx,by,br){ const dx=ax-bx,dy=ay-by; return dx*dx+dy*dy <= (ar+br)*(ar+br); }

/* Speech bubbles */
let delta=0;
function say(entity,line,secs=2.5){ if(!entity) return; entity.speech={text:line,t:secs}; const now=performance.now(), next=(entity._nextVoiceAt||0); const isBoss=(entity===boss); const chan=isBoss?"boss":"enemy"; if(now>=next){ TTS.speak(line,chan); entity._nextVoiceAt = now + (isBoss?1200:1600); } }
function drawBubble(x,y,text){ if(!text) return; const pad=6,r=8,maxW=240; ctx.save(); ctx.font="12px system-ui,Segoe UI,Roboto,Helvetica,Arial"; const words=text.split(" "); let line="",lines=[],test; for(const w of words){ test=line?line+" "+w:w; if(ctx.measureText(test).width>maxW){ lines.push(line); line=w; } else line=test; } if(line) lines.push(line); const w=Math.min(maxW,Math.max(40,...lines.map(l=>ctx.measureText(l).width)))+pad*2, h=lines.length*16+pad*2; const bx=Math.round(x-w/2), by=Math.round(y-46-h); ctx.fillStyle="rgba(15,18,32,0.95)"; ctx.strokeStyle="rgba(255,255,255,0.85)"; ctx.lineWidth=2; roundRect(ctx,bx,by,w,h,r); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x-6,by+h); ctx.lineTo(x+6,by+h); ctx.lineTo(x,by+h+8); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle="#eaf2ff"; lines.forEach((l,i)=>ctx.fillText(l,bx+pad,by+pad+12+i*16)); ctx.restore(); }
function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

/* Best score */
function saveBest(){ const key="best:"+level; const prev=+localStorage.getItem(key)||0; if(score>prev) localStorage.setItem(key,score); ui.best.textContent=Math.max(score,prev); ui.bestLevel.textContent=level; }

/* Effective skin rule */
function effectiveSkinForLevel(lvl){ if(lvl==="grocery") return "M1walk.png"; if(lvl==="office") return pick(["M2walk.png","M3walk.png"]); return skin; }
function colRFromGrid(g, scale){ return Math.max(16, Math.floor(g.fw*scale*0.35)); }

/* Player */
async function createPlayer(skinFile){
  const g=await SpriteGrid("Assets/"+skinFile); const a=new Animator(g,10); a.dir="right";
  const scale=SCALE[level]; const r=colRFromGrid(g, scale);
  return {
    x:120,y:canvas.height*0.62,scale,anim:a,r,
    hp:100,maxHp:100, st:150,maxSt:150, regen:28,
    lives:3, maxLives:5, inv:0, shield:0, cheap:0, tri:0, costMul:1.0,
    update(dt){
      const up=keys["KeyW"]||keys["ArrowUp"], dn=keys["KeyS"]||keys["ArrowDown"];
      const lf=keys["KeyA"]||keys["ArrowLeft"], rt=keys["KeyD"]||keys["ArrowRight"];
      let vx=(rt?1:0)-(lf?1:0), vy=(dn?1:0)-(up?1:0); if(vx||vy){ [vx,vy]=nrm(vx,vy); }
      const sp=240; this.x+=vx*sp*dt; this.y+=vy*sp*dt;
      const pb=playerBox(), cl=clampRect(this.x,this.y,pb); this.x=cl.x; this.y=cl.y;
      if(Math.abs(vx)>Math.abs(vy)) this.anim.dir=vx>=0?"right":"left"; else if(Math.abs(vy)>0.01) this.anim.dir=vy>=0?"down":"up";
      this.inv=Math.max(0,this.inv-dt); this.shield=Math.max(0,this.shield-dt); this.cheap=Math.max(0,this.cheap-dt); this.tri=Math.max(0,this.tri-dt);
      this.costMul=this.cheap>0?0.6:1.0; this.st=Math.min(this.maxSt,this.st+this.regen*dt);
      const moving=(vx||vy); this.anim.state=moving?"walk":"idle"; this.anim.speed=moving?sp:0; this.anim.update(dt);
    },
    draw(){
      if(this.inv>0){ ctx.save(); ctx.globalAlpha=0.55+0.45*Math.sin(performance.now()/50); this.anim.draw(ctx,this.x,this.y,this.scale); ctx.restore(); }
      else this.anim.draw(ctx,this.x,this.y,this.scale);
      if(this.shield>0){ ctx.save(); ctx.strokeStyle="#7dd3fc"; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(this.x,this.y-12,Math.max(28,this.r+6),0,Math.PI*2); ctx.stroke(); ctx.restore(); }
      if(this.speech?.t>0){ drawBubble(this.x,this.y-28,this.speech.text); this.speech.t-=delta; }
    }
  };
}
function bossKey(lvl){ return "bossSheet:"+lvl; }

/* ============================ Boss (UNIVERSAL ATTACKS + ðŸ’© Critical) === */
async function createBoss(){
  const pool = POOLS[level];
  let url = localStorage.getItem(bossKey(level));
  if (!url || !pool.includes(url)) { url = pick(pool); localStorage.setItem(bossKey(level), url); }

  const g = await SpriteGrid("Assets/"+url);
  const a = new Animator(g, 10); a.dir = "left";

  const scale = SCALE[level]*BOSS_MULT;
  const colR  = Math.max(18, Math.floor(g.fw*scale*0.35));
  const hp    = Math.round(700*parseFloat(ui.hp.value));

  ui.boss.textContent  = url;
  ui.scale.textContent = scale.toFixed(2)+"Ã—";

  // movement pattern state
  let patTimer=0, pattern="orbit", dashCD=0, ang=Math.random()*Math.PI*2;
  const bb=bossBox(); const base=120;
  function choosePattern(){ pattern=pick(["orbit","figure8","stripes","zigzag","swoop","dash"]); patTimer=2.2+Math.random()*2.0; ang=Math.random()*Math.PI*2; }

  // attacks for ALL bosses
  const attackSet = BOSS_BASE_ATTACKS[level] || [{ ch: pick(MINION_EMOJI), speed:440, damage:10 }];
  let throwCD   = 0.9;         // regular shots (all bosses)
  let enrageCD  = 0.35;        // ðŸ’© cadence when â‰¤20% HP
  let criticalAnnounced = false;

  function shootAtPlayer(spec, spreadY=18){
    const px = player.x, py = player.y + rand(-spreadY, spreadY);
    spawnEnemyEmoji(boss.x-30, boss.y+rand(-36,36), spec.ch, spec.speed, px, py, spec.damage);
  }

  function pooStorm(){
    // radial burst
    const n = 8 + (Math.random()*4|0);
    for(let i=0;i<n;i++){
      const a = Math.random()*Math.PI*2;
      const s = rand(300, 520);
      enemyShots.push({
        ch:"ðŸ’©", friendly:false,
        x:boss.x-24, y:boss.y+rand(-26,26),
        vx:Math.cos(a)*s, vy:Math.sin(a)*s,
        r:14, dmg:POO_SPEC.damage, life:2.6,
        update(dt){ this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dt; },
        draw(){ drawEmoji(this.ch,this.x,this.y,28); }
      });
    }
    // a couple aimed
    for(let k=0;k<2;k++) shootAtPlayer(POO_SPEC, 8);
  }

  const boss = {
    url, scale, colR,
    x: lerp(bb.l, bb.r, 0.85),
    y: lerp(bb.t, bb.b, 0.5),
    vx:-70, vy:0,
    hp, maxHp:hp,
    anim:a,

    update(dt){
      // ---------- movement ----------
      patTimer -= dt; if (patTimer<=0) choosePattern();
      ang += dt*(0.8+Math.random()*0.7);
      let targetV = { vx:-60, vy:0 };
      if(pattern==="orbit"){
        const cx=lerp(bb.l,bb.r,0.65), cy=lerp(bb.t,bb.b,0.5);
        const toC=[cx-this.x, cy-this.y]; const [nx,ny]=nrm(...toC);
        targetV.vx = -ny*base*1.1 - 30; targetV.vy = nx*base*1.1;
      } else if(pattern==="figure8"){
        targetV.vx = Math.cos(ang)*base*0.9 - 30;
        targetV.vy = Math.sin(ang*2)*base*0.6;
      } else if(pattern==="stripes"){
        targetV.vx = -base*(0.6+0.3*Math.sin(ang*1.5));
        targetV.vy =  base*Math.sin(ang*2.3)*0.9;
      } else if(pattern==="zigzag"){
        targetV.vx = -base*(0.8+0.2*Math.sin(ang*3.0));
        targetV.vy =  base*Math.sign(Math.sin(ang*2.2))*120;
      } else if(pattern==="swoop"){
        targetV.vx = -base*(0.7+0.4*Math.sin(ang*1.7));
        targetV.vy =  base*Math.sin(ang)*1.2;
      } else if(pattern==="dash"){
        dashCD -= dt;
        if(dashCD<=0){
          dashCD = 0.6+Math.random()*0.8;
          const dirY = (Math.random()<0.5?-1:1);
          targetV.vx = -260 - Math.random()*160;
          targetV.vy =  dirY*(140+Math.random()*120);
        }
      }
      this.vx = lerp(this.vx, targetV.vx, 0.12);
      this.vy = lerp(this.vy, targetV.vy, 0.12);
      this.x  += this.vx*dt; this.y += this.vy*dt;

      // keep on-screen (respect magic border)
      const bb2=bossBox();
      if(this.y<bb2.t){ this.y=bb2.t; this.vy=Math.abs(this.vy)*0.85; }
      if(this.y>bb2.b){ this.y=bb2.b; this.vy=-Math.abs(this.vy)*0.85; }
      if(this.x<bb2.l){ this.x=bb2.l; this.vx=Math.abs(this.vx)*0.85; }
      if(this.x>bb2.r){ this.x=bb2.r; this.vx=-Math.abs(this.vx)*0.85; }

      // anim
      if(Math.abs(this.vx)>Math.abs(this.vy)) this.anim.dir=(this.vx>=0)?"right":"left";
      else                                    this.anim.dir=(this.vy>=0)?"down":"up";
      const sp=Math.hypot(this.vx,this.vy);
      this.anim.state = (this.hp<=this.maxHp*0.20) ? "dash" : (sp>5?"walk":"idle");
      this.anim.speed = sp;
      this.anim.update(dt);

      // ---------- ATTACKS ----------
      const isCritical = this.hp <= this.maxHp*0.20;

      // base scene shots (all bosses)
      throwCD -= dt;
      if(throwCD<=0){
        throwCD = isCritical ? (0.45+Math.random()*0.35) : (0.65+Math.random()*0.5);
        const shots = 1 + (Math.random()<0.45?1:0);
        for(let i=0;i<shots;i++){
          const spec = (level==="office")
            ? pick(OFFICE_BOSS_EMOJI)
            : (Math.random()<0.25 ? { ch:pick(MINION_EMOJI), speed:440, damage:10 }
                                   : pick(attackSet));
          shootAtPlayer(spec);
        }
        if(Math.random()<0.35) say(this, pick(LINES[level]||LINES.coffee));
      }

      // ðŸ’© enraged phase
      if(isCritical){
        if(!criticalAnnounced){ criticalAnnounced=true; say(this, pick(LINES.bossLow), 2.2); }
        enrageCD -= dt;
        if(enrageCD<=0){
          enrageCD = 0.22;   // faster = wilder
          pooStorm();
          if(Math.random()<0.5) say(this, pick(LINES.bossLow));
        }
      }
    },

    draw(){
      const x=canvas.width-300,y=20,w=270,h=10;
      ctx.fillStyle="#142034"; ctx.fillRect(x-2,y-2,w+4,h+4);
      ctx.fillStyle="#0b1220"; ctx.fillRect(x,y,w,h);
      ctx.fillStyle=(this.hp/this.maxHp<0.20)?"#f59e0b":"#ef4444";
      ctx.fillRect(x,y,w*(this.hp/this.maxHp),h);
      this.anim.draw(ctx,this.x,this.y,this.scale);
      if(this.speech?.t>0){ drawBubble(this.x,this.y-28,this.speech.text); this.speech.t-=delta; }
    },

    hit(dmg){ this.hp=Math.max(0,this.hp-dmg); this.anim.freeze=0.1; if(Math.random()<0.4) say(this,pick(LINES.bossLow)); }
  };

  say(boss, pick(LINES[level]||LINES.coffee));
  choosePattern();
  return boss;
}

/* Enemy */
async function spawnEnemy(){
  const url=pick(POOLS[level]); const g=await SpriteGrid("Assets/"+url); const a=new Animator(g,10); a.dir="left";
  const pattern=pick(["straight","zigzag","swoop","dasher"]); const speed=rand(120,180);
  const hp=Math.round(rand(40,70)*parseFloat(ui.hp.value));
  const scale=SCALE[level]; const colR=colRFromGrid(g, scale);
  const e={
    x:canvas.width+40,y:rand(PLAY_TOP+30,canvas.height-50),vx:-speed,vy:0,scale,anim:a,
    hp,maxHp:hp,t:0,pattern,throwCD:rand(0.9,1.8),bodyDmg:10,colR,talkTimer:rand(1.2,2.6),
    update(dt){
      this.t+=dt; this.talkTimer-=dt;
      if(this.pattern==="zigzag"){ this.vy=Math.sin(this.t*4)*90; }
      else if(this.pattern==="swoop"){ this.vy=Math.sin(this.t*2.2+this.y*0.005)*70; this.vx=-speed*(0.75+0.25*Math.sin(this.t*1.7)); }
      else if(this.pattern==="dasher"){ this.vx=-speed*(1.0+0.75*(Math.sin(this.t*3.0)>0?1:0)); }
      this.x+=this.vx*dt; this.y=Math.max(PLAY_TOP+20, Math.min(canvas.height-50, this.y+this.vy*dt));
      if(this.y<=PLAY_TOP+20 && this.vy<0) this.vy*=-0.7;
      if(this.talkTimer<=0){ this.talkTimer=rand(3.5,6.0); say(this,pick(LINES[level]||LINES.coffee)); }
      this.throwCD-=dt; if(this.throwCD<=0){ this.throwCD=rand(1.0,2.2); const ch=pick(MINION_EMOJI); spawnEnemyEmoji(this.x-24,this.y+rand(-18,18),ch,rand(360,440),player.x,player.y+rand(-14,14),8); if(Math.random()<0.65) say(this,pick(LINES[level]||LINES.coffee)); }
      this.anim.state="walk"; this.anim.speed=Math.hypot(this.vx,this.vy); this.anim.update(dt);
      if(this.x<-80||this.hp<=0) this.dead=true;
    },
    draw(){ this.anim.draw(ctx,this.x,this.y,this.scale); if(this.speech?.t>0){ drawBubble(this.x,this.y-24,this.speech.text); this.speech.t-=delta; } }
  };
  if(Math.random()<0.7) say(e,pick(LINES[level]||LINES.coffee),2.5);
  enemies.push(e);
}

/* Projectiles */
function throwPlayer(){
  const spec=PLAYER_EMOJI[level]; if(!spec) return;
  const cost=spec.stamina*player.costMul; if(player.st<cost) return; player.st-=cost; sfxThrow();
  const makeShot=(vy)=>({ch:spec.ch,friendly:true,x:player.x+28,y:player.y-18,vx:spec.speed,vy, r:14, dmg:spec.damage, life:2.4});
  if(player.tri>0) playerShots.push(makeShot(-120),makeShot(0),makeShot(120)); else playerShots.push(makeShot(0));
}
function spawnEnemyEmoji(x,y,ch,speed,tx,ty,damage){
  const dx=tx-x,dy=ty-y,len=Math.hypot(dx,dy)||1; const vx=dx/len*speed,vy=dy/len*speed;
  enemyShots.push({ ch,friendly:false,x,y,vx,vy,r:14,dmg:damage||10,life:3.0,
    update(dt){ this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dt; },
    draw(){ drawEmoji(this.ch,this.x,this.y,28); }
  });
}

/* Props */
function buildProps(){
  props.length=0;

  if(level==="grocery"){
    for(let y=PLAY_TOP+60; y<=540; y+=120){
      props.push({type:"cone", x:canvas.width*0.55, y, r:18});
    }
  }

  if(level==="parking"){
    for(let y=PLAY_TOP+50; y<=520; y+=150){
      props.push({type:"cone", x:canvas.width*0.60, y, r:18});
    }
    for(let y=PLAY_TOP+20; y<=560; y+=100){
      props.push({type:"mailbox", x:canvas.width*0.40, y, r:20});
    }
  }

  if(level==="neighborhood"){
    for(let y=PLAY_TOP+10; y<=560; y+=100){
      props.push({type:"mailbox", x:canvas.width*0.55, y, r:20});
    }
  }

  if(level==="office"){
    props.push({type:"cooler",  x:canvas.width*0.35, y:canvas.height*0.65, r:22, cool:0});
    props.push({type:"mailbox", x:canvas.width*0.50, y:canvas.height*0.45, r:20});
  }
}


/* Powerups */
const POWERUP_TYPES=[{type:"shield",ch:"ðŸ›¡ï¸",dur:6},{type:"life",ch:"â¤ï¸"},{type:"stam",ch:"â˜•",amt:50},{type:"cheap",ch:"âš¡",dur:10},{type:"tri",ch:"âœ¨",dur:10}];
function spawnPowerup(){ const spec=pick(POWERUP_TYPES); powerups.push({ ...spec, x:canvas.width+30, y:rand(PLAY_TOP+40,canvas.height-60), vx:-140, vy:rand(-20,20), life:10 }); }
function updatePowerups(dt){ powerTimer-=dt; if(powerTimer<=0){ powerTimer=rand(9,14); spawnPowerup(); } for(const p of powerups){ p.x+=p.vx*dt; p.y=Math.max(PLAY_TOP+30, Math.min(canvas.height-50, p.y+p.vy*dt)); p.life-=dt; if(hitCircle(player.x,player.y-10,player.r, p.x,p.y,18)){ applyPowerup(p); p.life=0; sfxPup(); } } powerups=powerups.filter(p=>p.life>0 && p.x>-60); }
function drawPowerups(){ for(const p of powerups){ drawEmoji(p.ch,p.x,p.y,30); } }
function applyPowerup(p){ if(p.type==="shield") player.shield=Math.max(player.shield,p.dur||6); else if(p.type==="life") player.lives=Math.min(player.maxLives,player.lives+1); else if(p.type==="stam") player.st=Math.min(player.maxSt,player.st+(p.amt||50)); else if(p.type==="cheap") player.cheap=Math.max(player.cheap,p.dur||10); else if(p.type==="tri") player.tri=Math.max(player.tri,p.dur||10); }

/* Bars + Background */
function drawBars(){
  ctx.fillStyle="#fff"; ctx.font="12px system-ui";
  const x=20,y=18,w=240,h=12;
  ctx.fillStyle="#0b1020"; ctx.fillRect(x-2,y-2,w+4,h+4); ctx.fillStyle="#0b1220"; ctx.fillRect(x,y,w,h);
  ctx.fillStyle= player.inv>0||player.shield>0 ? "#60a5fa" : "#ef4444"; ctx.fillRect(x,y,w*(player.hp/player.maxHp),h);
  ctx.fillStyle="#fff"; ctx.fillText("Health",x,y-6);
  const y2=y+22;
  ctx.fillStyle="#0b1020"; ctx.fillRect(x-2,y2-2,w+4,h+4); ctx.fillStyle="#0b1220"; ctx.fillRect(x,y2,w,h);
  ctx.fillStyle="#22c55e"; ctx.fillRect(x,y2,w*(player.st/player.maxSt),h); ctx.fillStyle="#fff"; ctx.fillText("Stamina",x,y2-6);
  ui.lives.textContent=player.lives;
  const act=[]; if(player.shield>0)act.push(`ðŸ›¡ï¸${player.shield.toFixed(0)}s`); if(player.cheap>0)act.push(`âš¡${player.cheap.toFixed(0)}s`); if(player.tri>0)act.push(`âœ¨${player.tri.toFixed(0)}s`);
  ui.pwr.textContent=act.length?act.join("  â€¢  "):"â€”";
  ctx.fillStyle="#111827"; ctx.fillRect(20,y2+24,160,20); ctx.fillStyle="#69e7c3"; ctx.fillText("Score: "+score,26,y2+38);
}
function drawBackground(){
  if(bgImg){
    const cw=canvas.width,ch=canvas.height, iw=bgImg.width,ih=bgImg.height;
    const scale=Math.max(cw/iw,ch/ih); const dw=iw*scale, dh=ih*scale; const dx=(cw-dw)/2, dy=(ch-dh)/2;
    ctx.drawImage(bgImg,dx,dy,dw,dh);
  } else { ctx.fillStyle="#2b2f3a"; ctx.fillRect(0,0,canvas.width,canvas.height); }
  const y=PLAY_TOP+16, shimmer=0.35+0.25*Math.sin(performance.now()/650);
  ctx.save(); ctx.globalAlpha=0.7; const grad=ctx.createLinearGradient(0,y-2,0,y+4); grad.addColorStop(0,`rgba(255,255,255,${0.10*shimmer})`); grad.addColorStop(1,`rgba(111,199,255,${0.55*shimmer})`); ctx.fillStyle=grad; ctx.fillRect(40,y, canvas.width-80, 4); ctx.restore();
}

/* Damage / collisions */
function damagePlayer(amount){ if(player.shield>0 || player.inv>0) return; const mult=parseFloat(ui.dmg.value); player.hp=Math.max(0, player.hp-amount*mult); }

/* Loop */
let spawnBase=1.3, last=performance.now();
async function loop(now=performance.now()){
  delta=Math.min(0.033,(now-last)/1000); last=now;

  if(!paused){
    spawnTimer-=delta; const slider=parseFloat(ui.spawn.value); const nextEvery=spawnBase/slider;
    if(spawnTimer<=0 && needBoss){ spawnTimer=nextEvery; spawnEnemy(); }
    crowdChatterTimer-=delta; if(crowdChatterTimer<=0 && enemies.length){ crowdChatterTimer=rand(3.5,6.0); const e=pick(enemies); if(e && !e.dead) say(e,pick(LINES[level]||LINES.coffee)); }
    updatePowerups(delta);
    if(keys["Space"]){ keys["Space"]=false; throwPlayer(); }
    player&&player.update(delta); enemies.forEach(e=>e.update(delta));
    playerShots.forEach(p=>{ p.x+=p.vx*delta; p.y+=p.vy*delta; p.life-=delta; });
    enemyShots.forEach(p=>p.update(delta));
    boss&&boss.update(delta); handleProps(delta);

    for(const p of playerShots){
      for(const e of enemies){ if(!e.dead && e.hp>0 && hitCircle(p.x,p.y,p.r, e.x,e.y-16,e.colR)){ e.hp-=p.dmg; p.life=0; sfxHit(); if(e.hp<=0){ e.dead=true; kills++; score+=25; if(Math.random()<0.35) say(e,pick(LINES.onDefeat)); } } }
      if(boss && boss.hp>0 && hitCircle(p.x,p.y,p.r, boss.x,boss.y-24,boss.colR)){ boss.hit(p.dmg); p.life=0; sfxHit(); score+=15; }
    }
    for(const p of enemyShots){ if(hitCircle(p.x,p.y,p.r, player.x,player.y-18,player.r)){ damagePlayer(p.dmg); p.life=0; sfxHit(); } }
    for(const e of enemies){ if(!e.dead && hitCircle(player.x,player.y-10,player.r, e.x,e.y-10,e.colR)){ damagePlayer(e.bodyDmg); e.dead=true; sfxHit(); } }

    enemies=enemies.filter(e=>!e.dead && e.x>-80 && e.hp>0);
    playerShots=playerShots.filter(p=>p.life>0 && p.x<canvas.width+40);
    enemyShots =enemyShots.filter(p=>p.life>0 && p.x>-60 && p.x<canvas.width+60 && p.y>60 && p.y<canvas.height-10);

    if(needBoss && kills>=16){ needBoss=false; boss=await createBoss(); }
    if(player.hp<=0){
      if(player.lives>0){ player.lives-=1; player.hp=player.maxHp; player.st=player.maxSt; player.inv=2.5; say(player,"Not today!",1.8); }
      else { paused=true; saveBest(); TTS.stop(); BGM.switchTo("splash"); titleHeading.textContent="Defeat â€” Press Play"; titleOverlay.style.display="flex"; }
    }
    if(!needBoss && boss && boss.hp<=0){ paused=true; score+=300; saveBest(); TTS.stop(); BGM.switchTo("splash"); say(boss,pick(LINES.onDefeat)); titleHeading.textContent="Victory â€” Choose another level"; titleOverlay.style.display="flex"; }
  }

  drawBackground(); drawProps(); drawPowerups();
  player&&player.draw(); enemies.forEach(e=>e.draw());
  playerShots.forEach(p=>drawEmoji(p.ch,p.x,p.y,28)); enemyShots.forEach(p=>p.draw());
  boss&&boss.draw(); drawBars();
  ui.score.textContent=score;

  requestAnimationFrame(loop);
}

/* Boot / UI */
async function boot(lvl){
  TTS.stop(); level=lvl; ui.level.textContent=lvl; localStorage.setItem("lastLevel",lvl);
  PLAY_TOP=LEVEL_BAND_Y[lvl]??110;
  await loadBG(lvl);
  enemies.length=0; playerShots.length=0; enemyShots.length=0; props.length=0; powerups.length=0;
  kills=0; needBoss=true; spawnTimer=0.2; powerTimer=rand(4,8); score=0; crowdChatterTimer=rand(2.5,4.5);
  const lvlSkin=effectiveSkinForLevel(level); player=await createPlayer(lvlSkin);
  document.querySelectorAll(".skin").forEach(c=>c.classList.toggle("sel",c.dataset.skin===lvlSkin));
  boss=null; buildProps();
  ui.best.textContent=+localStorage.getItem("best:"+level)||0; ui.bestLevel.textContent=level; ui.lives.textContent=player.lives;
}

function hideTitle(){ titleOverlay.style.display="none"; initAudio(); }

// Keep loop running for splash + UI, but do not boot a level yet
requestAnimationFrame(loop);

// Start splash music on first click handled by armSplashOnce()
// Boot the level only when pressing Play:
document.getElementById("titlePlay").onclick = async ()=>{
  hideTitle(); TTS.stop(); paused = false;
  await boot(level);
  if (musicOn) BGM.switchTo(level);
};
document.getElementById("btnPlay").onclick  = async ()=>{
  hideTitle(); TTS.stop(); paused = false;
  if(!player) await boot(level); else if(musicOn) BGM.switchTo(level);
};
document.getElementById("btnPause").onclick = ()=>{ paused=true; TTS.stop(); };
document.getElementById("btnResetBoss").onclick = ()=>{ Object.keys(POOLS).forEach(k=>localStorage.removeItem(bossKey(k))); ui.boss.textContent="â€”"; };

document.querySelectorAll(".lvl").forEach(b=> b.addEventListener("click", async ()=>{
  hideTitle(); TTS.stop(); paused=false;
  await boot(b.dataset.lvl);
  if (musicOn) BGM.switchTo(level);
}));
document.querySelectorAll(".skin").forEach(chip=>{
  chip.addEventListener("click", async ()=>{
    document.querySelectorAll(".skin").forEach(c=>c.classList.remove("sel"));
    chip.classList.add("sel"); skin=chip.dataset.skin; localStorage.setItem("playerSkin",skin);
    if(player){ await boot(level); if(musicOn) BGM.switchTo(level); }
  });
});
document.getElementById("toggleVoices").onclick = ()=>{ voicesOn=!voicesOn; if(!voicesOn) TTS.stop(); $("#vState").textContent=voicesOn?"On":"Off"; };
document.getElementById("toggleSfx").onclick    = ()=>{ sfxOn=!sfxOn; $("#sState").textContent=sfxOn?"On":"Off"; };
document.getElementById("toggleMusic").onclick  = ()=>{
  musicOn=!musicOn; $("#mState").textContent=musicOn?"On":"Off";
  if(!musicOn) BGM.stop(); else { initAudio(); if(titleOverlay.style.display!=="none") BGM.switchTo("splash"); else BGM.switchTo(level); }
};
</script>
</body>
</html>
